# Язык разметки MARKDOWN
---
### Кратко

Markdown — удобочитаемый язык разметки, который прозрачно конвертируется в HTML. Его можно открывать и изменять в любом редакторе текста. Широко используется для написания документаций и README-файлов.

Вы можете встретить Markdown в .md или .markdown файлах. Он содержит базовые элементы, которые можно найти почти в любом README.md:

- заголовок первого уровня для названия;
- выделение жирным шрифтом важных частей в описании;
- ссылка с понятным текстом;
- заголовок второго уровня для подпунктов;
- маркированный список для перечисления преимуществ.

Несмотря на то, что Markdown достаточно удобно читать в исходном виде, его часто переводят в HTML.

## Синтаксис

### Параграф

Параграф — это одна или несколько подряд идущих строчек текста, отделённых одной или несколькими пустыми строчками. Если строка содержит только пробелы или табы, то она всё равно считается пустой.

Подряд идущие строчки будут склеены в одну, если не добавить жёсткий перенос. Существует несколько способов, как это можно сделать:
- добавить два (или больше) пробелов в конце строки <пробел><пробел>;
- добавить обратную косую черту в конце строки \;
- добавить HTML-тег переноса строки (br).

В англоязычных источниках для обозначения стилей написания заголовков используются термины Atx-style (для решёток) и Setext-style (для подчёркиваний).

### Решётки (Atx-style) 
Для того чтобы выделить заголовок, необходимо поставить от 1 до 6 решёток (#) и пробел в самом начале строки. Уровень заголовка зависит только от количества решёток.

- # Заголовок 1 уровня
- ## Заголовок 2 уровня
- ### Заголовок 3 уровня
- #### Заголовок 4 уровня
- ##### Заголовок 5 уровня
- ###### Заголовок 6 уровня
### Подчёркивания (Setext-style) 

«Подчёркивание» параграфа знаками равно (=) или дефисами (-) делает его заголовком первого или второго уровня соответственно. Уровень заголовка зависит только от типа «чёрточек», их количество значения не имеет. Между текстом и «подчёркиванием» не должно быть пустых строк.

Заголовок 1 уровня
==================

Заголовок 2 уровня
------------------

Заголовок, который подчеркнули одним символом
-

Заголовок второго
уровня из нескольких
строчек текста
------------------

### Списки 

#### Маркированные.
Для создания маркированных (ненумерованных) списков перед каждым пунктом нужно поставить минус (-), плюс (+) или звёздочку (*). Маркер и текст пункта необходимо разделять пробелом.

- Помидор
- Огурец

+ Бублик
+ Ватрушка

* Молоко
* Кефир

#### Упорядоченные

Если в качестве маркеров использовать цифры c точкой на конце (1., 2. и т. д.), то мы получим упорядоченный (нумерованный) список. Число перед первым пунктом показывает с чего нужно начинать нумеровать элементы списка, поэтому если в Markdown поставить 99., 1., 2., то в итоговой разметки пункты будут стоять под номерами 99, 100, 101.

1. Хлеб
2. Молоко
3. Помидоры

#### Вложенность 

Любые списки можно вкладывать друг в друга, для этого перед маркером нужно поставить таб или несколько пробелов.

+ Хлеб
+ Молочные продукты
  1. Кефир
  2. Ряженка

1. Молоко
2. Хлебобулочные изделия
    + Бублик
    + Ватрушка

Количество пробелов, которое нужно использовать, чтобы вложить один список в другой, может варьироваться. Оно зависит от количества символов в родительском маркере (L):

+ — 1 символ (L = 1)
1. — 2 символа (L = 2)
99. — 3 символа (L = 3)

Перед вложенным списком нужно поставить от L + 1 до L + 4 пробелов.

### Цитаты

Если в начале строки поставить треугольную скобку (>), то Markdown превратит текст после неё в цитату. Внутри могут быть любые блоки: параграфы, заголовки или даже другие цитаты.

> Одна треугольная скобка
превращает в цитату несколько строк,
идущих друг за другом.

> # Цитаты великих людей
> Ваша работа заполнит большую часть жизни и единственный способ быть
> полностью довольным — делать то, что по-вашему является великим делом.
> И единственный способ делать великие дела — любить то, что вы делаете.
>
> *— Стив Джобс, Речь в Стенфорде*

> Первая, родительская цитата
> > А это уже вторая,\
> > дочерняя цитата

### Исходный код

Markdown позволяет специальным образом размечать исходный код, все символы внутри будут автоматически экранированы. Есть 3 способа, как это можно сделать:

Обернуть код одной-двумя парами бэктиков (`код`)
Обернуть код тремя и более парами бэктиков (```код```)
Поставить таб или 4 пробела перед каждой строчкой кода

#### Одна-две пары бэктиков
Этот способ позволяет вставлять исходный код как строчный элемент. Даже если фактически у нас будет несколько строчек кода, обёрнутых бэктиками, мы всё равно получим одну строку после конвертации в HTML.

Функция `alert()`
вызывает диалоговое окно.

Сумму двух переменных
можно вывести так:
``const a = 1
const b = 2
alert(a + b)``

#### Три и более пары бэктиков
Если обернуть одну строчку кода тремя или более парами бэктиков, то мы получим строчный элемент, а если несколько строчек, то — блочный. Второй вариант позволяет указывать язык программирования, который мы используем, для этого нужно написать его сразу после открывающих бэктиков.

После обозначения языка программирования визуально ничего не изменится, но это даст возможность дополнительным плагинам и скриптам подсветить код внутри блока.

Функция ```console.log()```
выводит текст в консоль.

Сумму двух переменных
можно вывести так:
```javascript
const a = 1
const b = 2

console.log(a + b)
```

#### Отступ
Другой способ выделить код — поставить перед ним таб или 4 пробела. Исходный код необходимо отделять пустой строкой от предыдущего блока.

Метод ```.toString()```
превращает числа в строку.

Его можно использовать так:

    const a = 1
    const b = 2

    (a + b).toString()

### Выделение текста 
Если обернуть текст звёздочками (*) или нижними подчёркиваниями (_), то он станет жирным или курсивным. Оба символа работают одинаково, стиль выделения зависит только от их количества:

одна пара * или _ сделает текст *курсивным*;

две пары * или _ сделают текст **жирным**;

три пары * или _ применят ***оба стиля***.

Обычный текст

*Курсивный текст*<br>
_Другой курсивный текст_

**Жирный текст**<br>
__Другой жирный текст__

***Оба стиля***<br>
___Оба стиля___<br>  

Для экранирования служебных символов Markdown нужно поставить обратную косую черту перед каждым из них (\*, \_, \*\*).

**_Оба стиля из \* и \__**<br>
__*Оба стиля из \* и \_*__

\*\*Экранирование звёзд\*\*<br>
\_\_\_Экранирование подчёркиваний\_\_\_

### Ссылки
Markdown предлагает 3 стиля разметки ссылок: строчный, справочный и автоматический.

#### Строчные
Для вставки ссылки в строчном стиле необходимо воспользоваться следующей конструкцией: [Текст ссылки]​(URL). Есть возможность добавить подсказку, для этого нужно после URL дописать текст в кавычках: [Текст ссылки]​(URL "Подсказка").

Привет, [Дока](https://doka.guide "Энциклопедия про web-dev")!

#### Справочные
Для вставки ссылки в справочном стиле нужно написать [Текст ссылки]​[Ключ] в том месте, где вы хотите её поместить, а где-нибудь выше или ниже добавить сноску [Ключ]: URL "Подсказка".

У [Доки][1] есть свой [репозиторий][repo].

#### Автоматические
Markdown позволяет использовать упрощённый вариант для вставки ссылок, для этого нужно просто обернуть URI треугольными скобками (<<URI>>).

Можно вставлять адреса электронной почты (<hi@doka.guide>), тогда мы автоматически получим ссылку типа mailto:.

### Изображения
Конструкции для вставки изображений очень похожи на те, что используются для ссылок. Предлагается 2 стиля разметки: строчный и справочный.

#### Строчные
Для вставки изображения в строчном стиле необходимо воспользоваться конструкцией !⁠[Alt текст]​(URL картинки). При желании можно добавить подсказку: !⁠[Alt текст]​(URL картинки "Подсказка").

![Одна собака](dog.png "Собака смотрит влево")

#### Горизонтальный разделитель 
Для разделения смысловых блоков можно использовать горизонтальную черту <hr>
Чтобы это сделать, необходимо поставить на одной строке три (или более) дефиса (-), подчёркивания (_) или звёздочки (*). Они не обязательно должны идти друг за другом, между ними могут быть табы или пробелы.

---
***
_	_	_

*  * *  *
------------

## Стандартизация 
```sh
У Markdown есть оригинальная спецификация от одного из создателей языка — Джона Грубера. К сожалению, она не всегда однозначно описывает синтаксис, из-за чего многие конвертеры Markdown работают по-разному. Чтобы исправить эту ситуацию, группа разработчиков «поклонников Markdown» создала CommonMark — спецификацию, которая описывает многие частные случаи, и эталонную реализацию парсера Markdown на JS.
```

## Диалекты
```sh
Простой Markdown не всегда подходит для тех или иных проектов, поэтому существуют спецификации, которые расширяют или сужают его.
```

```sh
GitHub Flavored Markdown 
GFM — один из диалектов Markdown, который, как можно догадаться из названия, используется на GitHub. Он основан на спецификации CommonMark и расширяет её дополнительными элементами: таблицами, списками задач и зачёркиваниями.
```

### Таблицы 
```sh
Колонки таблицы размечаются с помощью вертикальных черт (|), а заголовок отделяется дефисами (-).
```
| Место | Участник | Рейтинг |
|-------|----------|---------|
| 1     | Саша     | 118     |
| 2     | Юля      | 92      |
| 3     | Даниил   | 36      |


```sh
Можно поставить двоеточие (:) рядом с дефисами для выравнивания текста:

по левой стороне (|:----|)
по центру (|:----:|)
по правой стороне (|----:|)
```
| Место | Участник | Рейтинг |
|------:|:--------:|:--------|
| 1     | Саша     | 118     |
| 2     | Юля      | 92      |
| 3     | Даниил   | 36      |




```sh
Ячейки таблицы могут не соответствовать друг другу по размеру.
```
|Место|Участник|Рейтинг|
|-:|:-:|:-|
|1|Саша|118|
|2|Юля|92|
|3|Даниил|36|

### Список задач 
```sh
Для создания списка задач используется синтаксис маркированного списка, но с добавлением чекбоксов ([ ] или [x]) после маркеров.
```

- [x] Выйти на улицу
- [x] Зайти в магазин
- [ ] Купить продукты
  - [x] Молоко
  - [x] Хлеб
  - [ ] Помидоры
- [ ] Вернуться домой


### Зачёркивание 
```sh
Если необходимо зачеркнуть текст, то можно поставить по две тильды (~~) в начале и в конце фрагмента.
```

~~Привет, Вова!~~\
Здравствуйте, Владимир!

## Работа с удалёнными репозиториями

Работа с удаленными репозиториями
Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версию вашего проекта, сохранённую в Интернете или ещё где-то в сети. У вас может быть несколько удаленных репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предусматривает управление удаленными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя возможность вводить новые, а также возможность контролировать соблюдение режима репозитория, а также возможность управлять различными удаленными ветками, заявлять об их отслеживаемости или отсутствии и так далее. В данном разделе мы рассмотрим некоторые из этих функций.

### Просмотр удаленных репозиториев
Для того, чтобы просмотреть список настроенных удаленных репозиториев, вы можете запустить команду git Remote. Она выведет название доступных удаленных репозиториев. Если вы клонировали репозитории, то покажите как минимум источник — имя по умолчанию, которое Git дает серверу, с которого произошло клонирование:

``` ш
$ git клон https://github.com/schacon/ticgit
Клонирование в « тикгит » …
удаленно: повторное использование существующего пакета: 1857, готово.
удаленное: всего 1857 (дельта 0), повторно использовано 0 (дельта 0)
Получение объектов: 100% (1857/1857), 374,35 КиБ | 268,00 КиБ/с, готово.
Разрешение дельт: 100% (772/772), готово.
Проверка подключения... завершена.
$ компакт-диск тикгит
$ git удаленный
источник
```
Вы также можете использовать ключ -v, чтобы просмотреть адрес для чтения и записи, юридические требования к репозиторию:

``` ш
$ git удаленный -v
происхождение https://github.com/schacon/ticgit (извлечь)
происхождение https://github.com/schacon/ticgit (push)
```
Если у вас больше одного удаленного репозитория, мы выведем их все. Например, для репозитория с несколькими настроенными удаленными репозиториями в случае совместной работы нескольких пользователей вывод команды может выглядеть примерно так:

``` sh $ cd зернистость
$ git удаленный -v
баккдор https://github.com/bakkdoor/grit (извлечь)
баккдор https://github.com/bakkdoor/grit (нажмите)
cho45 https://github.com/cho45/grit (извлечь)
cho45 https://github.com/cho45/grit (нажмите)
несуществующий https://github.com/defunkt/grit (извлечь)
несуществующий https://github.com/defunkt/grit (push)
коке git://github.com/koke/grit.git (извлечь)
коке git://github.com/koke/grit.git (push)
происхождение git@github.com:mojombo/grit.git (выборка)
происхождение git@github.com:mojombo/grit.git (push)
```
Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записей и в них можно внести свои изменения, вывод команды не дает никакой информации о правах доступа.

### Добавление удаленных репозиториев
В предыдущих разделах мы уже упоминали и приводили примеры добавления удаленных репозиториев, теперь рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (короткое имя), просто выполните команду git Remote add <shortname> <url> :

``` ш
$ git удаленный
источник
$ git удаленное добавление pb https://github.com/paulboone/ticgit
$ git удаленный -v
происхождение https://github.com/schacon/ticgit (извлечь)
происхождение https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (извлечь)
пб https://github.com/paulboone/ticgit (push)
```
Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у вас, но у вас их нет, вы можете выбрать команду git fetch pb:

``` ш
$ git fetch pb
удаленно: Подсчет объектов: 43, готово.
удаленно: Сжатие объектов: 100% (36/36), выполнено.
удаленное: всего 43 (дельта 10), повторно используемое 31 (дельта 5)
Распаковка объектов: 100% (43/43), выполнено.
С https://github.com/paulboone/ticgit.
 * [новая ветка] мастер - > pb/master
 * [новая ветка] ticgit - > pb/ticgit
 ```
Ветка master из репозитория Пола сейчас доступна вам под именем pb/master. Вы можете слить ее с одной из ваших веток или переключить ее на локальную ветку, чтобы просмотреть стандартные ветки Пола.

### Получение изменений из удаленного репозитория — Fetch and Pull
Как вы только что узнали, для получения данных из удаленных проектов следует выполнить выборку:

``` ш
$ git fetch [имя-удалённого]
```
Данное соединение связывается с удаленным проектом и собирает все данные проекта, команда которых у вас еще нет. После того, как вы выполнили команду, вы должны отобразить ссылки на все ветки из этого удаленного проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, программа clone автоматически добавляет этот удаленный репозиторий под именем «origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важное замечание: команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с собой, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git для получения большего количества информации), то вы можете использовать команду git pull, чтобы автоматически получать изменения из удалённой ветки и слить их с текущей текущей. Этот способ может оказаться для вас более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master для отслеживания удалённой ветки master на сервере, с которой вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на экране. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и пытается автоматически слить (слить) их с кодом, над которым вы в данный момент работает.

### Отправка изменений в удаленный репозиторий (Push)
Если вы хотите поделиться своими наработками, вам необходимо отправить их в удаленный репозиторий. Команда для этого действия проста: git push < имя-удалённого_сервера > < имя-ветви >. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете настроить эту команду для отправки ваших коммитов:

``` ш
$ git push origin master
```
Это выполняется только в том случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнил команду push. Если вы и кто-то еще одновременно клонируете, затем он подает команду push, а после того, как он выберет команду push, пробуете вы, то ваш push точно будет отклонён. Вам нужно сначала получить изменения и изучить их с вашими, и только после этого вам будет достаточно корректно нажать. Обратитесь к главе «Ветвление» в Git для получения более подробного описания, как вносить изменения на удаленный сервер.

### Просмотр удаленного репозитория
Если вы хотите получить больше информации об одном из удаленных репозиториев, вы можете использовать команду git Remote Show <remote> . Выполнив эту команду с каким-либо именем, например, origin, вы получите следующий результат:

``` ш
$ git удаленно показать происхождение
* удаленное происхождение
  Получить URL-адрес: https://github.com/schacon/ticgit.
  Нажмите URL-адрес: https://github.com/schacon/ticgit.
  НАЧАЛЬНАЯ ветка: мастер
  Удаленные филиалы:
    мастер отслеживал
    ветка разработки отслеживается
  Локальная ветка настроена для  « git pull » :
    мастер объединяется с удаленным мастером
  Локальная ссылка настроена для  « git push » :
    мастер отправляет мастеру (обновлено)
```
Она выдает URL удаленного репозитория, а также информацию об отслеживаемых ветках. Это любезно сообщает вам, что если вы, виртуальный мастер на ветке, выполните команду git pull, мастер-ветка с удаленного сервера будет автоматически влита в ваш компьютер сразу после получения всех необходимых данных. Она также выдает список всех полученных ссылок.

Это был пример простой ситуации, и вы наверняка встретились с каким-то консультантом. Однако, если вы используете Git более интенсивно, вы сможете увидеть гораздо большее количество информации от git Remote Show:

``` ш
$ git удаленно показать происхождение
* удаленное происхождение
  URL: https://github.com/my-org/complex-project.
  Получить URL-адрес: https://github.com/my-org/complex-project.
  Нажмите URL-адрес: https://github.com/my-org/complex-project.
  НАЧАЛЬНАЯ ветка: мастер
  Удаленные филиалы:
    мастер отслеживал
    ветка разработки отслеживается
    отслеживаемая полоса уценки
    выпуск-43 новый (следующая выборка будет храниться в каталоге Remotes/Origin)
    выпуск-45 новый (следующая выборка будет храниться в каталоге Remotes/Origin)
    refs/remotes/origin/issue-11 устаревший (для удаления используйте ' git Remote Prune ' )
  Локальные ветки, настроенные для  « git pull » :
    dev-ветвь объединяется с удаленной dev-ветвью
    мастер объединяется с удаленным мастером
  Локальные ссылки, настроенные для  « git push » :
    dev-branch отправляет в dev-branch (обновлено)
    markdown-strip перемещает в markdown-strip (обновлено)
    мастер отправляет мастеру (обновлено)
```
При этом показано, какая именно локальная ветка будет отправлена ​​на удаленный сервер по умолчанию при выполнении git push. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки ещё всё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении git pull.

### Удаление и переименование удаленных репозиториев
Для переименования удаленного репозитория можно выполнить git Remote Rename. Например, если вы хотите переименовать pb в paul, вы можете сделать это с помощью git Remote Rename:

``` ш
$ git удаленное переименование PB Пола
$ git удаленный
источник
Павел
```
Стоит упомянуть, что это также изменит имена удалённых веток в ваших репозиториях. То, к чему вы обращались как pb/master, теперь стало paul/master.

Если по какой-то причине вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не использовали определенное зеркало, или кто-то начал вносить изменения — вы можете использовать git Remote RM:

``` ш
$ git удаленно удалить Пола
$ git удаленный
источник
```
При удалении ссылок на удаленный репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, также будут удалены.
